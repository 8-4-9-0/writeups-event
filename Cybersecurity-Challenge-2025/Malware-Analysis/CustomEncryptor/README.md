## CustomEncryptor (405pt / 20 solves) [★★★☆]
> 重要なファイルがランサムウェアにより暗号化されてしまいました。  
> 一方で、ランサムウェアに不備があるため復元できるとの噂があります。
> 
> 
> 問題ファイルをダウンロード: CustomEncryptor.zip
> 
> ZIPのパスワード: `CybersecurityChallenge`
> 
> ZIPのハッシュ値(SHA256): `afa351514647173b1a3f047bd7e0f37e49d0aa4b2ce4b821c810cd97cdb9200f`

配布zip内にはランサムウェアらしき実行ファイルと暗号化されたisoファイル（拡張子として`.encrypted`がファイル名末尾に追加されている）が入っている。とりあえずGhidraで解析を......と思ったが、どうやら.NETアプリケーションらしい。dnSpyの出番だ。

プログラムの構造は以下の画像の通り。

<img src="images/image01.png" width="60%"></img>

まず、プログラムの大まかな流れを担う`Encrypt()`を以下に示す。
```cs
public void Encrypt(string filepath)
{
    if (this._disposed)
    {
        throw new ObjectDisposedException(base.GetType().FullName);
    }
    using (FileStream fileStream = new FileStream(filepath, FileMode.Open, FileAccess.ReadWrite, FileShare.None))
    {
        using (MemoryStream memoryStream = new MemoryStream())
        {
            fileStream.CopyTo(memoryStream);
            memoryStream.Seek(0L, SeekOrigin.Begin);
            byte[] original = memoryStream.ToArray();
            ValueTuple<byte[], Aes> valueTuple = this.EncryptUsingAes(original);
            byte[] item = valueTuple.Item1;
            Aes item2 = valueTuple.Item2;
            byte[] array = this.GenerateEncryptedFooter(item2);
            fileStream.Seek(0L, SeekOrigin.Begin);
            fileStream.Write(item, 0, item.Length);
            fileStream.Write(array, 0, array.Length);
        }
    }
    string text = Path.ChangeExtension(filepath, Path.GetExtension(filepath) + ".encrypted");
    if (File.Exists(text))
    {
        File.Delete(text);
    }
    File.Move(filepath, text);
}
```

要は、入力したファイルに対し「AESで暗号化した入力ファイル」+「暗号化されたフッター」を返すプログラムであることが分かる。AES暗号化の詳細は`EncryptUsingAes()`から、フッターの中身は`GenerateEncryptedFooter()`から知ることができる。
```cs
private ValueTuple<byte[], Aes> EncryptUsingAes(byte[] original)
{
    Aes aes = Aes.Create();
    aes.Mode = CipherMode.CBC;
    aes.Padding = PaddingMode.PKCS7;
    aes.Key = this.GetRandomArray(32);
    aes.IV = this.GetRandomArray(16);
    Trace.Assert(aes.BlockSize == 128);
    ValueTuple<byte[], Aes> result;
    using (MemoryStream memoryStream = new MemoryStream())
    {
        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateEncryptor(), CryptoStreamMode.Write, true))
        {
            cryptoStream.Write(original, 0, original.Length);
        }
        memoryStream.Seek(0L, SeekOrigin.Begin);
        result = new ValueTuple<byte[], Aes>(memoryStream.ToArray(), aes);
    }
    return result;
}
```
```cs
private byte[] GenerateEncryptedFooter(Aes aes)
{
	byte[] array = Array.Empty<byte>().Concat(aes.Key).Concat(aes.IV).Concat(Encoding.UTF8.GetBytes("TheFooterContent")).ToArray<byte>();
	Trace.Assert(array.Length == 64);
	byte[] array2 = this._rsa.Encrypt(array, RSAEncryptionPadding.OaepSHA1);
	Trace.Assert(array2.Length == 256);
	return array2;
}
```

AESの鍵、IVともに乱数を用いて生成されている。`GetRandomArray()`は引数で指定したサイズ分の乱数を生成する独自の関数となっている。  
フッターはAESの鍵、IVそして`TheFooterContent`という文字列が順番に繋がった64バイトのデータであるらしい。しかし内容はRSA-OAEP（ハッシュアルゴリズムはSHA1）により暗号化され、最終的には256バイトになっている。ではRSAの鍵はどこにあるのかというと、`CreateRsaCipherFromResource()`から分かる。これは`Main()`から呼び出されているものである。
```cs
private static void Main(string[] args)
{
	if (args.Length == 2 && args[0] == "--encrypt")
	{
		using (Encryptor encryptor = new Encryptor(Program.CreateRsaCipherFromResource()))
		{
			encryptor.Encrypt(args[1]);
			return;
		}
	}
	Program.ShowHelp();
}
```
```cs
private static RSA CreateRsaCipherFromResource()
{
    RSA result;
    using (Stream manifestResourceStream = Assembly.GetCallingAssembly().GetManifestResourceStream("CustomEncryptor.PublicKey"))
    {
        if (manifestResourceStream == null)
        {
            throw new InvalidOperationException("The expected resource is not found.");
        }
        using (MemoryStream memoryStream = new MemoryStream())
        {
            manifestResourceStream.CopyTo(memoryStream);
            memoryStream.Seek(0L, SeekOrigin.Begin);
            byte[] keyBlob = memoryStream.ToArray();
            RSACryptoServiceProvider rsacryptoServiceProvider = new RSACryptoServiceProvider();
            rsacryptoServiceProvider.ImportCspBlob(keyBlob);
            result = rsacryptoServiceProvider;
        }
    }
    return result;
}
```

`Assembly.GetCallingAssembly().GetManifestResourceStream("CustomEncryptor.PublicKey"))`より、アプリケーション内に鍵がリソースとして埋め込まれていることが分かるので、dnSpyのResourcesフォルダから抜き出して単体で保存する。  
ただしWebツール等で復号しようと思うとこのままでは使えず、PEM形式に変換する必要がある。もちろん変換せずに自前のC#アプリケーションを用意して復号したりするのもアリだと思うが、面倒だったのでLLMに変換用Pythonスクリプトを書いてもらった。

```python
import struct
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Hex をバイナリに変換
with open('CustomEncryptor.PublicKey', 'rb') as f:
    blob = f.read()
#blob = bytes.fromhex(hex_blob)

# バイナリパース
# 参考: https://learn.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-creating-and-using-a-key-container

# Skip PUBLICKEYSTRUC (first 8 bytes)
# Offset 0:   1 byte - bType (PRIVATEKEYBLOB = 0x07)
# Offset 1:   1 byte - bVersion
# Offset 2-3: 2 bytes - reserved
# Offset 4-7: 4 bytes - aiKeyAlg (e.g. CALG_RSA_KEYX = 0xa400)
# Offset 8-11: Magic ("RSA2" = private key)
# Offset 12-15: bitlen (key length in bits)
# Offset 16-19: pubexp (public exponent)

bType, bVersion, reserved, alg_id = struct.unpack("<BBHI", blob[0:8])
if bType != 0x07:
    raise ValueError("Not a PRIVATEKEYBLOB")

# Next is RSAPUBKEY structure (20 bytes)
# typedef struct _RSAPUBKEY {
#   DWORD magic;    // 0x32415352 ('RSA2' for private keys)
#   DWORD bitlen;   // length of modulus in bits
#   DWORD pubexp;   // public exponent
# } RSAPUBKEY;

magic, bitlen, pubexp = struct.unpack("<III", blob[8:20])
if magic != 0x32415352:
    raise ValueError("Not an RSA private key blob (magic mismatch)")

modulus_len = bitlen // 8  # bytes

# Private key params follow in this order:
# modulus (modulus_len bytes, little-endian)
# prime1 (modulus_len/2 bytes)
# prime2 (modulus_len/2 bytes)
# exponent1 (modulus_len/2 bytes)
# exponent2 (modulus_len/2 bytes)
# coefficient (modulus_len/2 bytes)
# private exponent (modulus_len bytes)

offset = 20
modulus = blob[offset:offset + modulus_len]
offset += modulus_len
prime1 = blob[offset:offset + modulus_len // 2]
offset += modulus_len // 2
prime2 = blob[offset:offset + modulus_len // 2]
offset += modulus_len // 2
exponent1 = blob[offset:offset + modulus_len // 2]
offset += modulus_len // 2
exponent2 = blob[offset:offset + modulus_len // 2]
offset += modulus_len // 2
coefficient = blob[offset:offset + modulus_len // 2]
offset += modulus_len // 2
priv_exponent = blob[offset:offset + modulus_len]

# These values are stored **little-endian** in the blob, convert to integers:
def le_bytes_to_int(b):
    return int.from_bytes(b, byteorder='little')

n = le_bytes_to_int(modulus)
e = pubexp
d = le_bytes_to_int(priv_exponent)
p = le_bytes_to_int(prime1)
q = le_bytes_to_int(prime2)
dp = le_bytes_to_int(exponent1)
dq = le_bytes_to_int(exponent2)
qi = le_bytes_to_int(coefficient)

# Build private key using cryptography
private_key = rsa.RSAPrivateNumbers(
    p=p,
    q=q,
    d=d,
    dmp1=dp,
    dmq1=dq,
    iqmp=qi,
    public_numbers=rsa.RSAPublicNumbers(e, n)
).private_key()

# Export private key to PEM
pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,  # PKCS#1 PEM
    encryption_algorithm=serialization.NoEncryption()
)

print(pem.decode())
```

変換により得られたPEM形式秘密鍵は以下の通り。
<details><summary>長いので折り畳み</summary>

```
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAvs/wzq0Tfu76gQ1VsY94HCM68jkXXRFUtiP7uGegGD/hYZqU
ZGOAVlUMT7KNni0jGo3bTYRhrbSnYEnK4tD445+I20Umtv9VEhe3eahfmj/ro3kb
bpauIMhk7BwK0rc08Tvenhx9gd55nvfrRWsXyF/fCaigUKfspnLBHW3/EXwIEwPT
ajecDsmS35khkaAI5ynFpTwzwbfId5OfmtLDqQoFnrTwz5ugcjitfpB0hGUWgYCS
y3me849ze0/1L8Izde3NtAkeEt25EzbjfV42HDTbHvGGSkKKcn9y+BE9y4DGQPot
WfChHTki01TrkZjQBA5JQuVrEDntQr3x1e8gcQIDAQABAoIBAEp/PwJCGpF9Vjpa
bXGUlQ1PR+1YEuIYKR2vsNCPTLcLAcCsrHEBVBLgw5y+FoKCFumAJvX90HEUTiDO
zrJ9ah7co38QYYwi5iDZN538+c5sVGCPoQEtPTC5bIWucR9Rvg7NFB5g+zNgG9XP
74A7zp5Bp//KYUT8Ou3FcdY+os49FMtiEafPcnxxfMFNFRM55KMqQ+flgv6mUxqF
Nctf3vK1W2FH/IXCAaG1zj61kYHSq0MhZ+J5RuN6ZaahwYMdUiqJJDhWuQDLZqH3
hfri9D33Czj5LRZvJrUmhi3fe56bAJ+XGkkcY0UNkdiUec4g9BpDpGUN79sti7qx
l6x/+G0CgYEA6QZjQ1iYteFFnTEnWf4thQS8Dj+/FlLbncTCsN+ya2JvEe7OYDLW
7zYYwqPT0bvt+sHqxQdK+4SYtxkBvEE6gpIDZJc56UELh7CaH9OT8v5QhiC5fmoF
5ePtDS5V7yxWQM4bQMnZvHBK66OXtAFelpITOye0KO1JhQliP9GtYE8CgYEA0aAX
7ElwIeYzE55l3qojoGDdH0wuhCIyqcZK+ztBN+Iw9QqaYM+HYJY0v5jqUSCwNN+G
U2U464XDNVrq8MbC8sFTNM0ZeHqSnclc7CPDP1DODw6u6Rgc5S/NKgYQ0MwFzOOZ
zNrH1t005wjGsCDpz63p5llcVMPJaIMFumFEgz8CgYBwQEV84abepp/0MwNz1H90
/mzgqFCSnmNwwqHOtlOqawZ6KwF7UcI8BWE0Edstw0vGabeAJh02wA8Y1JEDcKCQ
2WmNAVRCSrUVLjtwbWltuphrpEP243fn4D4HBXUb+82o9iAmu5WJssZEcM/ZRHee
LMvaySt+M6Ag1/5eI9FS/QKBgQCLpMSLCZkDXCCmbxyZqmm1SxHC6bMLHuT1KD2H
A0A9BBdtBbU1zMn4U9er0yg1Bzua3VTUdVfnveH+xyQ/ZYk0wgi14fOXyL+nER8v
x9sncKL0cOmgKgoFu0RHPGczUNaEWRJ53zzFK/Mz/Squ5h4b1VU9uEXDyfGAB9hn
AqjrbQKBgHUUGE6EUJwMwqKuWguUysSF8I5tXaYiIatJBBNDaOp8aY8tE7LQl7uC
/a0Fz74ek/VpU48/Z1+ZbZzGlC4PuLuZE0JrlXOgBdmAygKnlNB2X7cJVW9uwqaA
Q2CcKz5c5eKk6l/KVS1r4iIWSvnPQ/BI497OSd3NgnO/NQ3rTCmb
-----END RSA PRIVATE KEY-----
```
</details>

こちらの鍵を使ってフッターを復号すると、しっかり平文が得られていることが確認できた。（"TheFooterContent"から分かる。CyberChefではなぜか上手く行かなかったので[こちらのサイト](https://emn178.github.io/online-tools/rsa/decrypt/)を使った）

<img src="images/image02.png" width="80%"></img>

あとは得られた鍵、IVでisoを復号するだけである。`EncryptUsingAes()`より、AESのCBCモード・PKCS#7パディングで暗号化されているので、その旨をLLMに伝えて復号スクリプトを書いてもらった。（これくらいは自分で書けるようになった方が良いのだろうけれど）
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

key = bytes.fromhex('d5c94f3c9b91a0b4add842cd1cd1f0894f0dc0cf1c552012189b5228b2f493fa')  # 16, 24, or 32 bytes key (AES-128/192/256)
iv = bytes.fromhex('d5b090b9609f67639a2640a8e1d6677a')   # 16 bytes IV
with open('secret.iso.encrypted', 'rb') as fr:
    encrypted = fr.read()

# 復号処理
cipher = AES.new(key, AES.MODE_CBC, iv)
decrypted = cipher.decrypt(encrypted)

# PKCS7パディングの削除
try:
    plaintext = unpad(decrypted, AES.block_size)
except ValueError:
    print("パディングの解除に失敗しました。キーやIVが間違っている可能性があります。")

with open('secret.iso', 'wb') as fw:
    fw.write(decrypted)
```

これで元のsecret.isoが得られる。後はマウントするなり7zipで展開するなりすれば、中にフラグの書かれたテキストファイルがある。

### `flag{W!7h_PR1V@TE_K3Y_C0M3$_GR3@T_R3$P0N51BI!I7Y}`